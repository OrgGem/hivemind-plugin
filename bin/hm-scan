#!/usr/bin/env node
/**
 * hm-scan â€” Quick scan utility for HiveMind state.
 *
 * Usage: hm-scan [--profile quick|focused|deep] [--json]
 *
 * Profiles:
 *   - quick: Current session only (brain.json)
 *   - focused: Session + recent hierarchy
 *   - deep: Full manifest traversal
 *
 * Exit codes:
 *   0 - Success
 *   1 - Error (no session, invalid state, etc.)
 */

import { existsSync, readFileSync } from "node:fs"
import { dirname, join } from "node:path"

const HIVEMIND_DIR = ".hivemind"

function findProjectRoot() {
  let dir = process.cwd()
  while (dir !== "/") {
    if (existsSync(join(dir, HIVEMIND_DIR))) {
      return dir
    }
    dir = dirname(dir)
  }
  return null
}

function loadJson(filePath) {
  try {
    return JSON.parse(readFileSync(filePath, "utf-8"))
  } catch {
    return null
  }
}

function quickScan(projectRoot, jsonOutput) {
  const brainPath = join(projectRoot, HIVEMIND_DIR, "brain.json")
  const brain = loadJson(brainPath)

  if (!brain) {
    return { error: "No brain.json found", code: 1 }
  }

  const result = {
    sessionId: brain.session?.id,
    status: brain.session?.governance_status,
    mode: brain.session?.mode,
    trajectory: brain.hierarchy?.trajectory,
    tactic: brain.hierarchy?.tactic,
    action: brain.hierarchy?.action,
    turns: brain.metrics?.turn_count,
    drift: brain.metrics?.drift_score,
    files: brain.metrics?.files_touched?.length || 0,
  }

  if (jsonOutput) {
    return { data: result, code: 0 }
  }

  return {
    data: `ðŸ“Š Session: ${result.status} | Mode: ${result.mode}
   ID: ${result.sessionId}
   Trajectory: ${result.trajectory || "(not set)"}
   Tactic: ${result.tactic || "(not set)"}
   Action: ${result.action || "(not set)"}
   Turns: ${result.turns} | Drift: ${result.drift}/100
   Files: ${result.files}`,
    code: 0,
  }
}

function focusedScan(projectRoot, jsonOutput) {
  const quick = quickScan(projectRoot, true)
  if (quick.error) return quick

  const hierarchyPath = join(projectRoot, HIVEMIND_DIR, "hierarchy.json")
  const hierarchy = loadJson(hierarchyPath)

  const result = {
    ...quick.data,
    hierarchy: hierarchy ? {
      totalNodes: countNodes(hierarchy.root),
      cursor: hierarchy.cursor,
    } : null,
  }

  if (jsonOutput) {
    return { data: result, code: 0 }
  }

  let output = quick.data + "\n"
  if (hierarchy?.root) {
    output += `\nHierarchy (${result.hierarchy.totalNodes} nodes):\n`
    output += renderTree(hierarchy.root, 0, 3)
  }
  return { data: output, code: 0 }
}

function deepScan(projectRoot, jsonOutput) {
  const focused = focusedScan(projectRoot, true)
  if (focused.error) return focused

  const anchorsPath = join(projectRoot, HIVEMIND_DIR, "anchors.json")
  const memsPath = join(projectRoot, HIVEMIND_DIR, "mems.json")
  const manifestPath = join(projectRoot, HIVEMIND_DIR, "sessions", "manifest.json")

  const anchors = loadJson(anchorsPath)
  const mems = loadJson(memsPath)
  const manifest = loadJson(manifestPath)

  const result = {
    ...focused.data,
    anchors: anchors ? {
      count: anchors.anchors?.length || 0,
      keys: (anchors.anchors || []).slice(0, 5).map(a => a.key),
    } : { count: 0, keys: [] },
    mems: mems ? {
      count: mems.mems?.length || 0,
    } : { count: 0 },
    sessions: manifest ? {
      active: manifest.active_stamp,
      total: Object.keys(manifest.sessions || {}).length,
    } : null,
  }

  if (jsonOutput) {
    return { data: result, code: 0 }
  }

  let output = focused.data + "\n"
  output += `\nAnchors: ${result.anchors.count}`
  if (result.anchors.keys.length > 0) {
    output += ` [${result.anchors.keys.join(", ")}]`
  }
  output += `\nMemories: ${result.mems.count}`
  if (result.sessions) {
    output += `\nSessions: ${result.sessions.total} total`
    if (result.sessions.active) {
      output += ` (active: ${result.sessions.active})`
    }
  }
  return { data: output, code: 0 }
}

function countNodes(node) {
  if (!node) return 0
  let count = 1
  for (const child of node.children || []) {
    count += countNodes(child)
  }
  return count
}

function renderTree(node, depth, maxDepth) {
  if (depth > maxDepth || !node) return ""
  const indent = "  ".repeat(depth)
  const status = node.status ? ` (${node.status})` : ""
  let output = `${indent}${node.level}: ${node.content}${status}\n`
  for (const child of node.children || []) {
    output += renderTree(child, depth + 1, maxDepth)
  }
  return output
}

function main() {
  const args = process.argv.slice(2)
  let profile = "quick"
  let jsonOutput = false

  for (const arg of args) {
    if (arg === "--json") {
      jsonOutput = true
    } else if (arg.startsWith("--profile=")) {
      profile = arg.split("=")[1]
    } else if (arg === "--help" || arg === "-h") {
      console.log(`hm-scan â€” Quick scan utility for HiveMind state

Usage: hm-scan [--profile quick|focused|deep] [--json]

Profiles:
  quick   - Current session only (default)
  focused - Session + recent hierarchy
  deep    - Full manifest traversal

Options:
  --json  - Output as JSON
  --help  - Show this help`)
      process.exit(0)
    } else if (["quick", "focused", "deep"].includes(arg)) {
      profile = arg
    }
  }

  const projectRoot = findProjectRoot()
  if (!projectRoot) {
    console.error("ERROR: No .hivemind directory found. Run from a HiveMind project.")
    process.exit(1)
  }

  let result
  switch (profile) {
    case "quick":
      result = quickScan(projectRoot, jsonOutput)
      break
    case "focused":
      result = focusedScan(projectRoot, jsonOutput)
      break
    case "deep":
      result = deepScan(projectRoot, jsonOutput)
      break
    default:
      console.error(`ERROR: Unknown profile: ${profile}`)
      process.exit(1)
  }

  if (result.error) {
    if (jsonOutput) {
      console.log(JSON.stringify({ error: result.error, success: false }))
    } else {
      console.error(`ERROR: ${result.error}`)
    }
    process.exit(result.code)
  }

  if (jsonOutput) {
    console.log(JSON.stringify({ success: true, data: result.data, timestamp: new Date().toISOString() }, null, 2))
  } else {
    console.log(result.data)
  }
  process.exit(0)
}

main()
