#!/usr/bin/env node
/**
 * hm-state — State validation and export utility.
 *
 * Usage: hm-state [--validate] [--summarize] [--export] [--json]
 *
 * Actions:
 *   --validate  - Schema validate all state files
 *   --summarize - Generate state summary
 *   --export    - Export state bundle
 *
 * Exit codes:
 *   0 - Success
 *   1 - Error (validation failed, invalid state, etc.)
 */

import { existsSync, readFileSync } from "node:fs"
import { dirname, join } from "node:path"

const HIVEMIND_DIR = ".hivemind"

// Expected schema for brain.json
const BRAIN_SCHEMA = {
  required: ["session", "hierarchy", "metrics"],
  session: {
    required: ["id", "governance_status", "mode"],
  },
  hierarchy: {
    required: ["trajectory"],
  },
  metrics: {
    required: ["turn_count", "drift_score"],
  },
}

// Expected schema for hierarchy.json
const HIERARCHY_SCHEMA = {
  required: ["root"],
}

// Expected schema for anchors.json
const ANCHORS_SCHEMA = {
  required: ["anchors", "version"],
}

// Expected schema for mems.json
const MEMS_SCHEMA = {
  required: ["mems", "version"],
}

function findProjectRoot() {
  let dir = process.cwd()
  while (dir !== "/") {
    if (existsSync(join(dir, HIVEMIND_DIR))) {
      return dir
    }
    dir = dirname(dir)
  }
  return null
}

function loadJson(filePath) {
  try {
    return JSON.parse(readFileSync(filePath, "utf-8"))
  } catch {
    return null
  }
}

function validateObject(obj, schema, path = "") {
  const errors = []
  
  if (!obj) {
    errors.push(`${path}: object is null or undefined`)
    return errors
  }

  for (const field of schema.required || []) {
    if (obj[field] === undefined) {
      errors.push(`${path}.${field}: required field missing`)
    }
  }

  // Validate nested schemas
  for (const [key, nestedSchema] of Object.entries(schema)) {
    if (key === "required") continue
    if (obj[key] && typeof nestedSchema === "object" && !Array.isArray(nestedSchema)) {
      errors.push(...validateObject(obj[key], nestedSchema, `${path}.${key}`))
    }
  }

  return errors
}

function validate(projectRoot, jsonOutput) {
  const errors = []
  const warnings = []

  // Check brain.json
  const brainPath = join(projectRoot, HIVEMIND_DIR, "brain.json")
  const brain = loadJson(brainPath)
  if (!brain) {
    errors.push("brain.json: file not found or invalid JSON")
  } else {
    errors.push(...validateObject(brain, BRAIN_SCHEMA, "brain"))
    
    // Additional validation
    if (brain.session?.governance_status && 
        !["LOCKED", "OPEN"].includes(brain.session.governance_status)) {
      warnings.push(`brain.session.governance_status: unexpected value "${brain.session.governance_status}"`)
    }
    if (brain.session?.mode && 
        !["plan_driven", "quick_fix", "exploration"].includes(brain.session.mode)) {
      warnings.push(`brain.session.mode: unexpected value "${brain.session.mode}"`)
    }
  }

  // Check hierarchy.json
  const hierarchyPath = join(projectRoot, HIVEMIND_DIR, "hierarchy.json")
  if (existsSync(hierarchyPath)) {
    const hierarchy = loadJson(hierarchyPath)
    if (!hierarchy) {
      errors.push("hierarchy.json: invalid JSON")
    } else {
      errors.push(...validateObject(hierarchy, HIERARCHY_SCHEMA, "hierarchy"))
    }
  }

  // Check anchors.json
  const anchorsPath = join(projectRoot, HIVEMIND_DIR, "anchors.json")
  if (existsSync(anchorsPath)) {
    const anchors = loadJson(anchorsPath)
    if (!anchors) {
      errors.push("anchors.json: invalid JSON")
    } else {
      errors.push(...validateObject(anchors, ANCHORS_SCHEMA, "anchors"))
    }
  }

  // Check mems.json
  const memsPath = join(projectRoot, HIVEMIND_DIR, "mems.json")
  if (existsSync(memsPath)) {
    const mems = loadJson(memsPath)
    if (!mems) {
      errors.push("mems.json: invalid JSON")
    } else {
      errors.push(...validateObject(mems, MEMS_SCHEMA, "mems"))
    }
  }

  // Check sessions directory
  const sessionsPath = join(projectRoot, HIVEMIND_DIR, "sessions")
  if (!existsSync(sessionsPath)) {
    warnings.push("sessions/: directory not found")
  }

  const result = {
    valid: errors.length === 0,
    errors,
    warnings,
  }

  if (jsonOutput) {
    return { data: result, code: result.valid ? 0 : 1 }
  }

  if (result.valid) {
    let output = "✅ State validation passed\n"
    if (warnings.length > 0) {
      output += "\nWarnings:\n"
      for (const w of warnings) {
        output += `  ⚠ ${w}\n`
      }
    }
    return { data: output, code: 0 }
  }

  let output = "❌ State validation failed\n\nErrors:\n"
  for (const e of errors) {
    output += `  ✗ ${e}\n`
  }
  if (warnings.length > 0) {
    output += "\nWarnings:\n"
    for (const w of warnings) {
      output += `  ⚠ ${w}\n`
    }
  }
  return { data: output, code: 1 }
}

function summarize(projectRoot, jsonOutput) {
  const brain = loadJson(join(projectRoot, HIVEMIND_DIR, "brain.json"))
  const hierarchy = loadJson(join(projectRoot, HIVEMIND_DIR, "hierarchy.json"))
  const anchors = loadJson(join(projectRoot, HIVEMIND_DIR, "anchors.json"))
  const mems = loadJson(join(projectRoot, HIVEMIND_DIR, "mems.json"))

  function countNodes(node) {
    if (!node) return 0
    let count = 1
    for (const child of node.children || []) {
      count += countNodes(child)
    }
    return count
  }

  const result = {
    session: brain ? {
      id: brain.session?.id,
      status: brain.session?.governance_status,
      mode: brain.session?.mode,
      turns: brain.metrics?.turn_count,
      drift: brain.metrics?.drift_score,
    } : null,
    hierarchy: hierarchy ? {
      totalNodes: countNodes(hierarchy.root),
      cursor: hierarchy.cursor,
    } : null,
    anchors: anchors ? {
      count: anchors.anchors?.length || 0,
    } : { count: 0 },
    mems: mems ? {
      count: mems.mems?.length || 0,
      shelves: [...new Set(mems.mems?.map(m => m.shelf) || [])],
    } : { count: 0, shelves: [] },
    files: {
      brain: !!brain,
      hierarchy: !!hierarchy,
      anchors: !!anchors,
      mems: !!mems,
    },
  }

  if (jsonOutput) {
    return { data: result, code: 0 }
  }

  let output = "=== HiveMind State Summary ===\n\n"

  if (result.session) {
    output += `Session: ${result.session.status} | Mode: ${result.session.mode}
  ID: ${result.session.id}
  Turns: ${result.session.turns} | Drift: ${result.session.drift}/100\n`
  } else {
    output += "Session: (none)\n"
  }

  if (result.hierarchy) {
    output += `\nHierarchy: ${result.hierarchy.totalNodes} nodes`
    if (result.hierarchy.cursor) {
      output += ` (cursor: ${result.hierarchy.cursor.slice(0, 8)}...)`
    }
    output += "\n"
  }

  output += `\nAnchors: ${result.anchors.count}\n`
  output += `Memories: ${result.mems.count}`
  if (result.mems.shelves.length > 0) {
    output += ` [${result.mems.shelves.join(", ")}]`
  }
  output += "\n"

  output += "\nFiles present: "
  const present = Object.entries(result.files)
    .filter(([_, v]) => v)
    .map(([k, _]) => k)
  output += present.length > 0 ? present.join(", ") : "(none)"

  return { data: output, code: 0 }
}

function exportState(projectRoot, jsonOutput) {
  const brain = loadJson(join(projectRoot, HIVEMIND_DIR, "brain.json"))
  const hierarchy = loadJson(join(projectRoot, HIVEMIND_DIR, "hierarchy.json"))
  const anchors = loadJson(join(projectRoot, HIVEMIND_DIR, "anchors.json"))
  const mems = loadJson(join(projectRoot, HIVEMIND_DIR, "mems.json"))

  const manifestPath = join(projectRoot, HIVEMIND_DIR, "sessions", "manifest.json")
  const manifest = loadJson(manifestPath)

  const result = {
    exportedAt: new Date().toISOString(),
    version: "2.6.0",
    brain,
    hierarchy,
    anchors,
    mems,
    manifest,
  }

  if (jsonOutput) {
    return { data: result, code: 0 }
  }

  // For non-JSON output, pretty print the bundle
  const output = JSON.stringify(result, null, 2)
  return { data: output, code: 0 }
}

function main() {
  const args = process.argv.slice(2)
  let doValidate = false
  let doSummarize = false
  let doExport = false
  let jsonOutput = false

  for (const arg of args) {
    if (arg === "--validate") {
      doValidate = true
    } else if (arg === "--summarize") {
      doSummarize = true
    } else if (arg === "--export") {
      doExport = true
    } else if (arg === "--json") {
      jsonOutput = true
    } else if (arg === "--help" || arg === "-h") {
      console.log(`hm-state — State validation and export utility

Usage: hm-state [--validate] [--summarize] [--export] [--json]

Actions:
  --validate  - Schema validate all state files
  --summarize - Generate state summary
  --export    - Export state bundle

Options:
  --json  - Output as JSON
  --help  - Show this help

If no action specified, defaults to --summarize`)
      process.exit(0)
    }
  }

  // Default to summarize if no action specified
  if (!doValidate && !doSummarize && !doExport) {
    doSummarize = true
  }

  const projectRoot = findProjectRoot()
  if (!projectRoot) {
    console.error("ERROR: No .hivemind directory found. Run from a HiveMind project.")
    process.exit(1)
  }

  let result
  if (doValidate) {
    result = validate(projectRoot, jsonOutput)
  } else if (doSummarize) {
    result = summarize(projectRoot, jsonOutput)
  } else if (doExport) {
    result = exportState(projectRoot, jsonOutput)
  }

  if (result.error) {
    if (jsonOutput) {
      console.log(JSON.stringify({ error: result.error, success: false }))
    } else {
      console.error(`ERROR: ${result.error}`)
    }
    process.exit(result.code)
  }

  if (jsonOutput && (doValidate || doSummarize || doExport)) {
    console.log(JSON.stringify({ success: true, data: result.data, timestamp: new Date().toISOString() }, null, 2))
  } else {
    console.log(result.data)
  }
  process.exit(result.code)
}

main()
